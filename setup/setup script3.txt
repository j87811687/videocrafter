#!/bin/bash
set -e

# =====================================================
# setup_videocrafter.sh
# Secure setup for VideoCrafter â€” now with:
# â€¢ Disk Space Check
# â€¢ Automatic logging
# â€¢ Idempotent installation
# â€¢ Secure Hugging Face token handling (env + Token Redaction)
# â€¢ Example input videos + functional test
# â€¢ Port Mapping Test
# =====================================================
# -------------------- Disk Space Check --------------------
MIN_FREE_GB=10
FREE_GB=$(df -BG / | awk 'END { gsub(/[^0-9]/, "", $4); print $4 }')

if [ "$FREE_GB" -lt "$MIN_FREE_GB" ]; then
    echo "âŒ Error: Only ${FREE_GB}GB free â€” need at least ${MIN_FREE_GB}GB."
    echo "    Tip: Increase disk size or clean unused models / caches."
    exit 1
else
    echo "ğŸ’½ Disk check OK â€” ${FREE_GB}GB free."
fi

echo "------------------------------------------------------------"
echo "ğŸš€ Starting secure VideoCrafter setup..."
echo "------------------------------------------------------------"

# -------------------- Utility --------------------
fail() {
    echo "âŒ $1"
    echo "Aborting setup. See log: $LOG_FILE"
    exit 1
}

# =====================================================
# Hugging Face Token Handling + Safe Redaction
# =====================================================

# Ensure HF token is provided via environment variable only
if [ -z "${HF_TOKEN}" ]; then
    echo "âŒ Missing Hugging Face token."
    echo "Please set it before running:"
    echo "  export HF_TOKEN=\"your_token_here\""
    fail "Hugging Face token not provided."
fi

echo "âœ… Using Hugging Face token from environment variable."

# -------------------- Logging --------------------
LOG_DIR="$HOME/logs"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/setup_$(date +%Y-%m-%d_%H-%M-%S).log"

echo "ğŸ—“ï¸ Log file: $LOG_FILE"

# -------------------- Token Redaction Mask --------------------
MASK_TOKEN() {
    sed -u "s/${HF_TOKEN}/[REDACTED]/g"
}

ENABLE_MASKING() {
    exec > >(MASK_TOKEN | tee -a "$LOG_FILE") 2>&1
}

ENABLE_MASKING

# -------------------- System Prep --------------------
echo "ğŸ“¦ Updating system packages..."
apt update && apt upgrade -y
apt install -y git wget curl jq pciutils git-lfs bc

# -------------------- Verify Hugging Face Token --------------------
echo "ğŸ§¾ Verifying Hugging Face token..."
USER_INFO=$(curl -s -H "Authorization: Bearer $HF_TOKEN" https://huggingface.co/api/whoami-v2)
USERNAME=$(echo "$USER_INFO" | jq -r '.name // empty')
if [ -z "$USERNAME" ]; then
    fail "Invalid Hugging Face token or unable to verify identity."
fi
echo "âœ… Token verified. Logged in as: $USERNAME"

echo "ğŸ” Checking access to repo: VideoCrafter/VideoCrafter..."
REPO_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $HF_TOKEN" https://huggingface.co/api/repos/VideoCrafter/VideoCrafter)
if [ "$REPO_CHECK" != "200" ]; then
    fail "Access to VideoCrafter repo denied (HTTP $REPO_CHECK)."
fi
echo "âœ… Repo access confirmed."

# -------------------- Conda Setup --------------------
if ! command -v conda &> /dev/null; then
    echo "ğŸ“¦ Installing Miniconda..."
    wget -q https://repo.anaconda.com/miniconda/Miniconda3-py310_24.3.0-0-Linux-x86_64.sh
    bash Miniconda3-py310_24.3.0-0-Linux-x86_64.sh -b -p $HOME/miniconda
    eval "$($HOME/miniconda/bin/conda shell.bash hook)"
    conda init
else
    echo "âœ… Conda already installed."
    eval "$(conda shell.bash hook)"
fi

# -------------------- Environment Creation --------------------
if ! conda info --envs | grep -q "videocrafter"; then
    echo "ğŸ Creating Conda environment..."
    conda create -y -n videocrafter python=3.10
else
    echo "âœ… Conda environment 'videocrafter' already exists."
fi
conda activate videocrafter

# -------------------- GPU's Compute Capability Detection --------------------
echo "ğŸ” Checking existing GPU and software environment..."
if command -v nvidia-smi &> /dev/null; then
    COMPUTE_CAP=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader | head -n 1)
	COMPUTE_CAP=$(echo "$COMPUTE_CAP" | sed -E 's/[^0-9\.]//g')
	[ -z "$COMPUTE_CAP" ] && COMPUTE_CAP="0.0"
    echo "ğŸ§  Detected GPU's Compute Capability: $COMPUTE_CAP"
else
    fail "No NVIDIA GPU detected!"
fi

# -------------------- CUDA/PyTorch Selection --------------------
if (( $(echo "$COMPUTE_CAP >= 9.0" | bc -l) )); then
    CUDA_VERSION="12.3"
    PYTORCH_CUDA="cu123"
elif (( $(echo "$COMPUTE_CAP >= 8.0" | bc -l) )); then
    CUDA_VERSION="12.1"
    PYTORCH_CUDA="cu121"
else
    CUDA_VERSION="11.8"
    PYTORCH_CUDA="cu118"
fi
echo "âš™ï¸ Recommended CUDA $CUDA_VERSION and PyTorch build $PYTORCH_CUDA"

# -------------------- Install / Update CUDA Toolkit --------------------
echo "=== Checking CUDA Toolkit version ==="
INSTALLED_CUDA=$(nvcc --version 2>/dev/null | grep "release" | sed -E 's/.*release ([0-9]+\.[0-9]+).*/\1/')
REQUIRED_CUDA="$CUDA_VERSION"

if [ -z "$INSTALLED_CUDA" ]; then
    echo "ğŸ“¦ CUDA Toolkit not found â€” installing version $REQUIRED_CUDA ..."
    conda install -y -c "nvidia/label/cuda-${REQUIRED_CUDA}" cuda-toolkit
else
    if python - <<EOF
from packaging import version as v
import sys
sys.exit(0 if v.parse("$INSTALLED_CUDA") >= v.parse("$REQUIRED_CUDA") else 1)
EOF
    then
        echo "âœ… CUDA Toolkit version $INSTALLED_CUDA is up to date."
    else
        echo "âš ï¸ CUDA Toolkit version $INSTALLED_CUDA is older â€” upgrading..."
        conda install -y -c "nvidia/label/cuda-${REQUIRED_CUDA}" cuda-toolkit
    fi
fi

# -------------------- Install / Update PyTorch (only if freeze missing) --------------------
FREEZE_OUTPUT="/root/requirements_inference_derived.txt"

if [ ! -f "$FREEZE_OUTPUT" ]; then
	echo "=== Checking PyTorch CUDA build ==="

	# If torch is not installed, install
	if ! python -c "import torch" &>/dev/null; then
  		echo "ğŸ”¥ PyTorch not found â€” installing build ($PYTORCH_CUDA)..."
    	pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/${PYTORCH_CUDA}
	else
    	# Torch exists â†’ check build
    	INSTALLED_TORCH_CUDA=$(python -c "import torch; print(torch.version.cuda)")
    	REQUIRED_TORCH_CUDA="${CUDA_VERSION}"

    	echo "ğŸ” Installed PyTorch CUDA: ${INSTALLED_TORCH_CUDA}"
    	echo "ğŸ” Required PyTorch CUDA: ${REQUIRED_TORCH_CUDA}"

		# Normalize CUDA versions to major.minor (handles 12.1 vs 12.1.0 vs 121)
		normalize_cuda_ver() {
		    echo "$1" | sed -E 's/[^0-9.]//g' | awk -F. '{print $1"."$2}'
		}
		
		NORM_INSTALLED=$(normalize_cuda_ver "$INSTALLED_TORCH_CUDA")
		NORM_REQUIRED=$(normalize_cuda_ver "$REQUIRED_TORCH_CUDA")
		
		echo "ğŸ” Normalized PyTorch CUDA: ${NORM_INSTALLED}"
		echo "ğŸ” Normalized Required CUDA: ${NORM_REQUIRED}"
		
		if [ "$NORM_INSTALLED" != "$NORM_REQUIRED" ]; then
		    echo "âš ï¸ PyTorch CUDA mismatch â€” reinstalling correct build..."
		    pip install --force-reinstall torch torchvision torchaudio \
		        --index-url https://download.pytorch.org/whl/${PYTORCH_CUDA}
		else
		    echo "âœ… PyTorch CUDA build matches requirement."
		fi
	fi
else
    echo "ğŸ” PyTorch install skipped (freeze file detected)"
fi

# -------------------- Install ffmpeg (NVIDIA build) --------------------
if command -v ffmpeg &>/dev/null && ffmpeg -version | grep -qi "NVIDIA"; then
    echo "âœ… NVIDIA FFmpeg already installed â€” skipping."
else
    echo "âš ï¸ Installing NVIDIA FFmpeg (with full NVENC/NVDEC)..."
    cd /tmp
    wget -q https://developer.download.nvidia.com/assets/ffmpeg/ffmpeg-nvidia-6.0-linux64.tar.gz
    tar -xzf ffmpeg-nvidia-6.0-linux64.tar.gz
    mv ffmpeg-nvidia /usr/local/bin/ffmpeg
    mv ffprobe-nvidia /usr/local/bin/ffprobe
    chmod +x /usr/local/bin/ffmpeg /usr/local/bin/ffprobe
    echo "âœ… NVIDIA FFmpeg installed with GPU acceleration."
fi

# -------------------- VideoCrafter Setup --------------------
STATE_FILE="/root/.videocrafter_state"
[ -f "$STATE_FILE" ] && source "$STATE_FILE"

([ ! -d "VideoCrafter/.git" ] || [ "${clone_successful:-0}" -eq 0 ]) && rm -rf VideoCrafter 2>/dev/null
if [ ! -d "VideoCrafter" ]; then
	echo "=== ğŸ“ Cloning VideoCrafter (commit dab0535) with strict verification ==="

	REPO_URL="https://github.com/AILab-CVC/VideoCrafter.git"
	PINNED_COMMIT="dab0535"
	EXPECTED_REPO_TREE_HASH="e6c19bed66c95d060c70432ae3191a8a7e327ba7f0fe61557b34ab4b281a5b76"
	MAX_CLONE_ATTEMPTS=5
	
	attempt=1
	clone_successful=0

	while [ $attempt -le $MAX_CLONE_ATTEMPTS ]; do
		echo "=== Clone attempt $attempt/$MAX_CLONE_ATTEMPTS ==="
		rm -rf VideoCrafter
	
		# Clone repo directly at commit (detached HEAD)
	    git clone --branch "$PINNED_COMMIT" "$REPO_URL"
	    if [ $? -ne 0 ]; then
	    	echo "âš ï¸ Git clone failed â€” retrying..."
			attempt=$((attempt+1))
			continue
	    fi

		cd VideoCrafter || {
            echo "âŒ VideoCrafter directory missing after clone."
            attempt=$((attempt+1)); continue
		}

        # -----------------------------
        # 1. STRICT SHALLOW CHECK
        # -----------------------------
        if git rev-parse --is-shallow-repository 2>/dev/null | grep -q "true"; then
            echo "âŒ Shallow clone detected â€” retrying..."
            cd ..
            attempt=$((attempt+1))
            continue
        fi

        # -----------------------------
        # 2. REQUIRED FILES / STRUCTURE
        # -----------------------------
        REQUIRED_ITEMS=(
            "requirements.txt"
            "LICENSE"
            "README.md"
            "configs"
            "scripts"
            "lvdm/models"
        )

        for item in "${REQUIRED_ITEMS[@]}"; do
            if [ ! -e "$item" ]; then
                echo "âŒ Missing required repo item: $item"
                echo "Retrying clone..."
                cd ..
                attempt=$((attempt+1))
                continue 2   # jump to next clone attempt
            fi
        done

        # -----------------------------
        # 3. TREE-HASH CONTENT CHECK (with retry for disk I/O issues)
        # -----------------------------
        echo "=== Verifying repository tree-hash ==="

		HASH_ATTEMPTS=5
		backoff=1

		for i in $(seq 1 $HASH_ATTEMPTS); do
            echo "Hash attempt $i/$HASH_ATTEMPTS..."

			TREE_HASH=$(find . -type f \
			    -not -path './.git/*' \
			    -not -name '.DS_Store' \
			    -not -name 'Thumbs.db' \
			    -not -name '*.swp' \
			    -not -name '*.tmp' \
			    -not -name '*~' \
			    -not -name 'desktop.ini' \
			    -print0 \
                | sort -z \
                | xargs -0 sha256sum 2>/dev/null \
                | sha256sum 2>/dev/null \
                | awk '{print $1}')

             # If hashing failed (empty or null), retry
             if [ -z "$TREE_HASH" ]; then
                echo "âš ï¸ Hashing failed â€” retrying in ${backoff}s..."
                sleep $backoff
                backoff=$((backoff * 2))
                continue
            fi
		done

        if [ "$TREE_HASH" != "$EXPECTED_REPO_TREE_HASH" ]; then
            echo "âŒ Repository checksum mismatch!"
            echo "Expected: $EXPECTED_REPO_TREE_HASH"
            echo "Got:      $TREE_HASH"
            echo "Retrying clone..."
            cd ..
            attempt=$((attempt+1))
            continue
        fi

        echo "âœ… Repository integrity verified."
        clone_successful=1
		# If the key exists â†’ replace the whole line
		if grep -q '^clone_successful=' "$STATE_FILE"; then
			sed -i 's/^clone_successful=.*/clone_successful=1/' "$STATE_FILE"
		else
			# If missing â†’ append
			echo "clone_successful=1" >> "$STATE_FILE"
		fi
		break
	done

	if [ $clone_successful -ne 1 ]; then
        echo "âŒ Failed to obtain a complete, verified clone after $MAX_CLONE_ATTEMPTS attempts."
		rm -rf VideoCrafter
		exit 1
	fi

	echo "âœ… VideoCrafter successfully cloned and verified at commit $PINNED_COMMIT."

else
    echo "âœ… VideoCrafter repo already present."
fi

cd VideoCrafter

# -------------------- Inference Freeze (create or install) --------------------
create_freeze() {
	WHITELIST_PATH="/root/inference_whitelist.txt"
	if [ -f "$FREEZE_OUTPUT" ]; then
	    echo "ğŸ“¦ Installing inference environment from existing freeze: $FREEZE_OUTPUT"
	    pip install -r "$FREEZE_OUTPUT" --no-deps
	    echo "âœ… Inference environment restored from freeze."
	else
	    echo "ğŸ“¦ Freeze not found â€” installing VideoCrafter Python requirements before creating freeze..."
	
	    pip install --upgrade pip
	    pip install -r requirements.txt
	    pip install huggingface_hub
	
	    if [ ! -f "$WHITELIST_PATH" ]; then
	
			WHITELIST_URL="https://raw.githubusercontent.com/j87811687/videocrafter/refs/heads/main/setup/inference_whitelist.txt"
			for attempt in 1 2 3; do
	    		echo "â¬‡ï¸ Downloading inference whitelist (attempt $attempt)..."
	    		curl -fsSL "$WHITELIST_URL" -o "$WHITELIST_PATH" && break
	    		sleep 2
			done
			if [ ! -f "$WHITELIST_PATH" ]; then
	    		echo "âŒ Failed to download inference whitelist after 3 attempts."
	    		echo "Cannot create inference-only freeze."
                return 0
			else
	    		echo "âœ… Inference whitelist downloaded: $WHITELIST_PATH"
			fi
		fi
	
		echo "ğŸ“¦ Creating inference-only freeze from current environment..."
		pip freeze > /tmp/full_freeze.txt
		grep -i -f "$WHITELIST_PATH" /tmp/full_freeze.txt > "$FREEZE_OUTPUT"
		
		echo "âœ… Created new inference freeze at: $FREEZE_OUTPUT"
	fi
}
create_freeze

# -------------------- Configure Hugging Face --------------------
mkdir -p ~/.huggingface
echo "{\"token\":\"$HF_TOKEN\"}" > ~/.huggingface/token.json

# -------------------- Download & Verify VideoCrafter Weights --------------------
mkdir -p checkpoints
cd checkpoints

REPO_URL="https://huggingface.co/VideoCrafter/VideoCrafter"
REPO_DIR="VideoCrafter"

# Minimal VC1 inference subset (I2V + T2V) - git files
REQUIRED_GIT_FILES=(
	"configs/inference/i2v_videocrafter.yaml"
	"configs/inference/t2v_videocrafter.yaml"
)

#  Minimal VC1 inference subset (I2V + T2V) - lfs tracked files, relevant for size comparison
REQUIRED_LFS_TRACKED_FILES=(
	"models/i2v/model.ckpt"
	"models/t2v/model.ckpt"
)

# Expected sizes and OIDs derived from pointer files (after clone, before first git lfs pull)
declare -A EXPECTED_SIZE
declare -A EXPECTED_OID

# Declare arrays fresh (they will be repopulated by sourcing)
declare -A STORED_SIZE
declare -A STORED_OID

# If state file exists, restore stored values into arrays and variables
if [ -f "$STATE_FILE" ]; then
	. "$STATE_FILE"
fi

load_pointer_metadata() {
	# Extract expected size + oid from working-tree pointer files ($REPO_DIR/$f),
	# called only after a fresh clone and BEFORE the first git lfs pull.
	for f in "${REQUIRED_LFS_TRACKED_FILES[@]}"; do

		if [ -n "${STORED_SIZE[$f]:-}" ]; then
			EXPECTED_SIZE["$f"]="${STORED_SIZE[$f]}"
			valid_size_files=$((valid_size_files+1))
			if [ -n "${STORED_OID[$f]:-}" ]; then
				EXPECTED_OID["$f"]="${STORED_OID[$f]}"
			fi
			continue
		fi

		local pointer_path="$REPO_DIR/$f"

		if [ ! -f "$pointer_path" ]; then
			echo "âŒ Failed to proper clone repo - missing pointer file."
			rm -rf "$REPO_DIR" 2>/dev/null || true
			if [ $clone_run -eq $MAX_CLONE_RUNS ]; then
				echo "âŒ Setup aborted â€” VideoCrafter is NOT operational."
				exit 1
			fi
			clone_run=$((clone_run+1))
			continue 2
		fi

		local size_line oid_line size_val oid_val
		size_line=$(grep -E '^size ' "$pointer_path" 2>/dev/null || true)
		oid_line=$(grep -E '^oid ' "$pointer_path" 2>/dev/null || true)

		size_val=$(echo "$size_line" | awk '{print $2}')
		oid_val=$(echo "$oid_line" | sed -E 's/^oid sha256://')

		if [ -n "$size_val" ]; then
			EXPECTED_SIZE["$f"]="$size_val"
			
			key="$f"
			val="${EXPECTED_SIZE[$key]}"
			# If the key exists â†’ replace the whole line
			if grep -q "^STORED_SIZE\[$key\]=" "$STATE_FILE"; then
				sed -i "s/^STORED_SIZE\[$key\]=.*/STORED_SIZE[$key]=$val/" "$STATE_FILE"
			else
				# If missing â†’ append
				echo "STORED_SIZE[$f]=${EXPECTED_SIZE[$f]}" >> "$STATE_FILE"
			fi
			valid_size_files=$((valid_size_files+1))
		else
			echo "âŒ Failed to proper clone repo - no size in pointer file."
			rm -rf "$REPO_DIR" 2>/dev/null || true
			if [ $clone_run -eq $MAX_CLONE_RUNS ]; then
				echo "âŒ Setup aborted â€” VideoCrafter is NOT operational."
				exit 1
			fi
			clone_run=$((clone_run+1))
			continue 2
		fi
		if [ -n "$oid_val" ]; then
			EXPECTED_OID["$f"]="$oid_val"

			key="$f"
			val="${EXPECTED_OID[$key]}"
			# If the key exists â†’ replace the whole line
			if grep -q "^STORED_OID\[$key\]=" "$STATE_FILE"; then
				sed -i "s/^STORED_OID\[$key\]=.*/STORED_OID[$key]=$val/" "$STATE_FILE"
			else
				# If missing â†’ append
				echo "STORED_OID[$f]=${EXPECTED_OID[$f]}" >> "$STATE_FILE"
			fi
		fi
	done
}

# Check all REQUIRED_LFS_TRACKED_FILES:
#  - if missing â†’ add to missing_list
#  - if exists and (actual size is empty OR size mismatch) â†’ delete file + LFS cache (if possible) and add to missing_list
find_missing_weights() {
	missing_list=()

	for f in "${REQUIRED_LFS_TRACKED_FILES[@]}"; do
		local full_path="$REPO_DIR/$f"

		if [ ! -f "$full_path" ]; then
			# Completely missing file
			missing_list+=("$f")
			continue
		fi

		# Extract actual size and compare sizes
		local expected_size="${EXPECTED_SIZE[$f]}"
		
		# Actual file size (Linux stat)
		local actual_size
		actual_size=$(stat -c%s "$full_path" 2>/dev/null || echo "")

		if [ -z "$actual_size" ] || [ "$actual_size" != "$expected_size" ]; then
			echo "âš ï¸ Size mismatch for $f (expected: ${expected_size} bytes, got: ${actual_size:-unknown})."
			echo "   Treating as corrupted LFS object â€” removing file and cache entry."

			# Delete working-tree file
			rm -f "$full_path" 2>/dev/null || true

			# Mark as missing so it will be re-downloaded
			missing_list+=("$f")
			continue
		fi
	done
}

# Helper: delete LFS cache objects for files on missing list (if we have its OID)
delete_lfs_cache_objects() {
	for f in "${missing_list[@]}"; do

		local oid="${EXPECTED_OID[$f]}"

		[ -n "$oid" ] || continue

		# OID is pure hex; first 2 + next 2 form subdirs
		local short1 short2 obj_path
		short1="${oid:0:2}"
		short2="${oid:2:2}"
		obj_path="$REPO_DIR/.git/lfs/objects/$short1/$short2/$oid"

		rm -f "$obj_path" 2>/dev/null || true
	done
}

git lfs install

MAX_WEIGHT_RUNS=2
weights_ok=0
run=1

while [ $run -le $MAX_WEIGHT_RUNS ]; do
	echo "=== VideoCrafter weights sync run $run/$MAX_WEIGHT_RUNS ==="

	MAX_CLONE_RUNS=3
	clone_run=1

	while [ $clone_run -le $MAX_CLONE_RUNS ]; do
		echo "=== VideoCrafter repo clone run $clone_run/$MAX_CLONE_RUNS ==="

		# If repo missing or invalid, start from a clean slate
		if [ ! -d "$REPO_DIR/.git" ]; then
			rm -rf "$REPO_DIR" 2>/dev/null || true
			echo "â¬‡ï¸ Cloning VideoCrafter repository (weights repo)..."

			for attempt in 1 2 3; do
				echo "ğŸ” git clone attempt $attempt/3..."
				GIT_LFS_SKIP_SMUDGE=1 git clone "$REPO_URL" "$REPO_DIR" && break
				sleep 3
			done

			if [ ! -d "$REPO_DIR/.git" ]; then
				echo "âŒ Failed to clone VideoCrafter weights repo after 3 attempts."
				if [ $clone_run -eq $MAX_CLONE_RUNS ]; then
					echo "âŒ Setup aborted â€” VideoCrafter is NOT operational."
					exit 1
				fi
				clone_run=$((clone_run+1))
				continue
			fi
		fi

		# Check for existence of git files
		for f in "${REQUIRED_GIT_FILES[@]}"; do
			if [ ! -f "$REPO_DIR/$f" ]; then
				rm -rf "$REPO_DIR" 2>/dev/null || true
				echo "âš ï¸ Missing GIT file detected: $f"
				if [ $clone_run -eq $MAX_CLONE_RUNS ]; then
					echo "âŒ Setup aborted â€” VideoCrafter is NOT operational."
					exit 1
				fi
				clone_run=$((clone_run+1))
				continue 2
			fi
		done

# CLONE SUCCESSFUL, 2 GIT FILES EXIST

		# After successful clone and BEFORE the first git lfs pull, extract pointer sizes
		EXPECTED_SIZE=()
		EXPECTED_OID=()
		valid_size_files=0
		load_pointer_metadata

		if [ "$valid_size_files" -eq 2 ]; then
			break
		fi
	done

# size extraction successful, 2 expected_size values exist

	# 1) Full LFS pull for this repo
	cd "$REPO_DIR"
	for attempt in 1 2 3; do
		echo "ğŸ” git lfs pull attempt $attempt/3..."
		git lfs pull && break
		sleep 3
	done
	cd ..

	# 2) First check
	find_missing_weights
	delete_lfs_cache_objects
	if [ ${#missing_list[@]} -eq 0 ]; then
		echo "âœ… All VideoCrafter weight files successfully verified."
		weights_ok=1
		break  # Exit the outer run loop
	fi

	echo "âš ï¸ Missing or corrupted LFS files detected:"
	printf ' - %s\n' "${missing_list[@]}"

	# 3) Force re-download of missing/corrupted files
	cd "$REPO_DIR"
	for f in "${missing_list[@]}"; do
		for attempt in 1 2 3; do
			echo "ğŸ” Forcing re-download of LFS file: $f, attempt $attempt/3..."
			if [ -n "${EXPECTED_OID[$f]}" ]; then
				git lfs pull --include="$f" && break
			else
				git lfs fetch --include="$f" --force
				git lfs checkout "$f" && break
			fi
			sleep 3
		done
	done
	cd ..

	# 4) Second check in this run
	find_missing_weights
	if [ ${#missing_list[@]} -eq 0 ]; then
		echo "âœ… All VideoCrafter weight files successfully verified after targeted re-download."
		weights_ok=1
		break  # Exit the outer run loop
	fi

	echo "âš ï¸ Missing files persist after targeted re-download in run $run/$MAX_WEIGHT_RUNS."
	echo "   Removing weights repo and preparing for a fresh attempt..."

	# Delete entire repo so next run re-clones fresh
	rm -rf "$REPO_DIR" 2>/dev/null || true

	run=$((run+1))
done

if [ $weights_ok -ne 1 ]; then
	echo "âŒ Missing required VideoCrafter weight files even after full retry:"
	printf ' - %s\n' "${missing_list[@]}"
	rm -rf "$REPO_DIR" 2>/dev/null || true
	echo "âŒ Setup aborted â€” VideoCrafter is NOT operational."
	exit 1
fi

echo "âœ… All VideoCrafter weight files successfully verified."
cd ..

# -------------------- Example Inputs --------------------
if [ -f examples/clip1.mp4 ]; then
    echo "ğŸ“ Example video already exists â€” skipping download."
else
    echo "â¬‡ï¸ Downloading example input videos..."
    mkdir -p examples
    wget -q -O examples/clip1.mp4 https://huggingface.co/datasets/ashawkey/videocrafter-samples/resolve/main/clip1.mp4
    wget -q -O examples/clip2.mp4 https://huggingface.co/datasets/ashawkey/videocrafter-samples/resolve/main/clip2.mp4
    echo "âœ… Example videos downloaded."
fi

# -------------------- Test Run (VC1 continuation + auto-concat) --------------------
echo "ğŸ¬ Running continuation test (last frame â†’ I2V + concat) using example clip..."
mkdir -p test_results

rm -f test_results/output.mp4
rm -f test_results/final_continuation.mp4
rm -f test_results/test_run.log
rm -f test_results/last_frame.png

ffmpeg -sseof -1 -i examples/clip1.mp4 -vf "scale=512:-1" \
    test_results/last_frame.png -y

python scripts/run_i2v.py \
    --input_image test_results/last_frame.png \
    --prompt "continue this scene smoothly" \
    --fps 24 \
    --num_frames 48 \
    --output_dir test_results \
    > test_results/test_run.log 2>&1 || \
    echo "âš ï¸ Test run failed â€” see test_results/test_run.log"

if [ ! -f "test_results/output.mp4" ]; then
    echo "âš ï¸ Continuation clip missing â€” check test_results/test_run.log"
else    
	printf "file '../examples/clip1.mp4'\nfile 'output.mp4'\n" > test_results/concat_list.txt
	cd test_results
	ffmpeg -f concat -safe 0 -i concat_list.txt -c copy final_continuation.mp4 -y
	cd ..
	
	if [ -f "test_results/final_continuation.mp4" ]; then
	    echo "âœ… Final continuation video created: test_results/final_continuation.mp4"
	else
	    echo "âš ï¸ Failed to build final continuation video."
	fi
fi

# -------------------- Port Mapping Test --------------------
if [ "${TEST_PORT_MAPPING_DONE:-false}" != "true" ]; then
	echo "ğŸ§ª Running first-time port mapping test..."
	while true; do
    	read -p "Enter a port number to test: " TEST_PORT
	    if [[ "$TEST_PORT" =~ ^[0-9]+$ ]] && [ "$TEST_PORT" -ge 1 ] && [ "$TEST_PORT" -le 65535 ]; then
	        break
	    else
	        read -p "âŒ Invalid port number. Try again? [y/n]: " RETRY
	        if [[ ! "$RETRY" =~ ^[Yy]$ ]]; then
	            echo "ğŸš« Port mapping test aborted by user."
	            exit 0
	        fi
	    fi
	done

	echo "ğŸŒ Starting temporary web server on port $TEST_PORT to verify mapping..."
	
	mkdir -p /workspace && cd /workspace
	python3 -m http.server $TEST_PORT >/tmp/webserver_test.log 2>&1 &
	SERVER_PID=$!
	trap "kill $SERVER_PID >/dev/null 2>&1" EXIT
	sleep 5

	if curl -s "http://localhost:$TEST_PORT" >/dev/null; then
		echo "âœ… Internal check: port $TEST_PORT is responding."
	else
		echo "âŒ Internal check failed â€” port $TEST_PORT not responding."
	fi
	
	echo "ğŸŒ You can now verify from your local machine: http://<INSTANCE_IP>:<EXTERNAL_PORT>"
	echo "â³ The test server will stop automatically in 60 seconds..."
	sleep 60
	kill $SERVER_PID >/dev/null 2>&1
	echo "ğŸ›‘ Test web server stopped."
	# If the key exists â†’ replace the whole line
	if grep -q '^TEST_PORT_MAPPING_DONE=' "$STATE_FILE"; then
		sed -i 's/^TEST_PORT_MAPPING_DONE=.*/TEST_PORT_MAPPING_DONE=true/' "$STATE_FILE"
	else
		# If missing â†’ append
		echo "TEST_PORT_MAPPING_DONE=true" >> "$STATE_FILE"
	fi
fi

echo ""
echo "ğŸ‰ Setup complete!"
echo "ğŸ—’ï¸ Full log saved at: $LOG_FILE"
echo "Activate environment with:"
echo "  conda activate videocrafter"






